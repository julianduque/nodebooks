"use client";

import { getMonaco } from "@/components/notebook/monaco-setup";
import { ensureCellModel, cellUri } from "@/components/notebook/monaco-models";
import {
  addModuleShim,
  ensurePackageTypes,
  setGlobalsDts,
} from "@/components/notebook/monaco-extra-libs";

type NotebookCell = {
  id: string;
  type: "code" | "markdown" | "terminal" | "command";
  language?: "js" | "ts";
  source?: string;
};

type CodeCell = Required<Pick<NotebookCell, "id">> & {
  type: "code";
  language: "js" | "ts";
  source: string;
};

function isCodeCell(cell: NotebookCell): cell is CodeCell {
  return cell.type === "code" && !!cell.language;
}

// Very lightweight top-level decl extraction using regex
// This is conservative and treats names as any.
export function buildGlobalsDts(cells: CodeCell[]): string {
  const decls: string[] = ["// Generated by NodeBooks: notebook globals"];

  for (const cell of cells) {
    const src = cell.source ?? "";
    // function foo() {...}
    const fnRe = /\bfunction\s+([A-Za-z_$][\w$]*)\s*\(/g;
    // class Foo {...}
    const classRe = /\bclass\s+([A-Za-z_$][\w$]*)\b/g;
    // const/let/var name = ... ; capture multiple via comma split
    const varRe = /\b(?:const|let|var)\s+([^;\n]+)[;\n]/g;

    let m: RegExpExecArray | null;
    while ((m = fnRe.exec(src))) {
      decls.push(`declare function ${m[1]}(...args: any[]): any;`);
    }
    while ((m = classRe.exec(src))) {
      decls.push(`declare class ${m[1]} { [k: string]: any }`);
    }
    while ((m = varRe.exec(src))) {
      const names = (m[1] ?? "")
        .split(",")
        .map((s) => s.trim())
        .map((s) => s.replace(/=.*/, ""))
        .map((s) => s.replace(/\{.*\}/, ""))
        .map((s) => s.replace(/\[.*\]/, ""))
        .map((s) => s.trim())
        .filter(Boolean);
      for (const name of names) {
        const ident = name.match(/^[A-Za-z_$][\w$]*/)?.[0];
        if (ident) decls.push(`declare var ${ident}: any;`);
      }
    }
  }

  return decls.join("\n");
}

// Collect bare module specifiers (no ./ or ../)
export function scanImportsForPackages(cells: CodeCell[]): string[] {
  const specs = new Set<string>();
  const importRe =
    /\bfrom\s+['"]([^'"]+)['"];?|\bimport\s+['"]([^'"]+)['"];?|require\(\s*['"]([^'"]+)['"]\s*\)/g;
  for (const cell of cells) {
    const src = cell.source ?? "";
    let m: RegExpExecArray | null;
    while ((m = importRe.exec(src))) {
      const spec = m[1] || m[2] || m[3];
      if (!spec) continue;
      if (
        spec.startsWith("./") ||
        spec.startsWith("../") ||
        spec.startsWith("/")
      )
        continue;
      specs.add(spec);
    }
  }
  return Array.from(specs);
}

// Keep per-notebook state so we can dispose models when switching
const notebookModels = new Map<string, Set<string>>();

export type SyncArgs = {
  notebookId: string;
  cells: NotebookCell[];
  currentCellId?: string | null;
};

let debounceTimer: ReturnType<typeof setTimeout> | null = null;

export function syncNotebookContext(args: SyncArgs) {
  // Debounce to avoid thrashing while user types
  if (debounceTimer) {
    clearTimeout(debounceTimer);
  }
  debounceTimer = setTimeout(() => doSync(args), 200);
}

function doSync({ notebookId, cells, currentCellId }: SyncArgs) {
  const monaco = getMonaco();
  if (!monaco) return;

  const codeCells = cells.filter(isCodeCell) as CodeCell[];
  const indexOf = (id?: string | null) =>
    id ? codeCells.findIndex((c) => c.id === id) : -1;
  const currentIndex = indexOf(currentCellId ?? null);

  const beforeCells =
    currentIndex >= 0 ? codeCells.slice(0, currentIndex) : codeCells;

  // Build/update globals from previous cells
  const globals = buildGlobalsDts(beforeCells);
  setGlobalsDts(globals);

  // Ensure models exist for previous cells (not for current to avoid duplicates)
  const createdUris = new Set<string>();
  beforeCells.forEach((cell, i) => {
    const uri = cellUri(notebookId, i, cell);
    createdUris.add(uri);
    ensureCellModel({ notebookId, order: i, cell, skipIfExists: false });
  });
  // Track models so we can clean them up if notebook changes drastically (optional)
  notebookModels.set(notebookId, createdUris);

  // Scan for packages and add shims/types
  const specs = scanImportsForPackages(codeCells);
  for (const spec of specs) {
    // Add a shim for the exact specifier; future: fetch types for root package
    addModuleShim(spec);
    void ensurePackageTypes(spec);
  }
}
